{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Helply","text":"<p>A user-friendly Python library designed to streamline the creation of \"help\" commands for Discord bots using application commands within the disnake library. This library will automatically parse your commands and provide details for each command, such as name, description, role and permission checks, etc.  As I'm a user of the disnake library, this is designed to be used with that project, but I do plan to add support for others in the future</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Consolidating various attributes from <code>InvokableApplicationCommand</code> and <code>APIApplicationCommand</code> into a single cached object.</li> <li>Parsing role and permission checks.</li> <li>Utility functions that provide ready-to-go embeds and pagination.</li> <li>Support localizing commands and arguments (New in version 0.3.0)</li> <li>Parsing command cooldowns (New in version 0.4.0)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the <code>helply</code> package, you will need git. If you don't have git installed on your system, you can download it from here.</p> <p>Once you have git installed, run the following command inside your Python environment to install the package:</p> <pre><code>pip install git+https://github.com/dlchamp/Helply\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>After installing the package, you can use it in your project by importing it as follows:</p> <pre><code>from helply import Helply\n</code></pre> <p>AppCommands will be created and cached upon first use of <code>helply</code> to retrieve commands. This allows all commands to become registered with Discord before <code>helply</code> steps in to create it's own objects with the consolidated attributes provided by <code>InvokableApplicationCommand</code> and <code>APIApplicationCommand</code></p>"},{"location":"#description-parsing","title":"Description parsing","text":"<p>Disnake will automatically parse your command descriptions from the docstring in your callback function, or by populating the <code>description</code> keyword argument. <code>Helply</code> uses that description, however, it also parses descriptions found in the <code>extras</code> key-word argument when it finds the \"help\" key.  This proves exceptionally useful for menu commands that do not normally have a description that is displayed by the user's client.</p> <p>Example - User Command: <pre><code># Since this is a user command that does not inherently have a description. We are using\n# extras to set the description for the help command.\n@bot.user_command(name=\"View Avatar\", extras={\"help\": \"Display the target user's avatar\"})\nasync def view_avatar(...):\n    ...\n</code></pre></p> <p>While designed to allow command descriptions for your menu commands, you may also use this feature to create longer descriptions for your slash commands as it would appear in your help response. For slash commands, this is really only useful if you wish to provide more information that would normally exceed the 100 character limit set by Discord.</p> <p>Important</p> <p>Setting <code>extras</code> will override your command.description when displayed in the help response.</p> <p>In this example, the user will see \"Kick a member from the server\" when attempting to use the command while \"Removes the target member from the guild\" will appear as the command description in the help response.</p> <pre><code>@bot.slash_command(\n    name=\"kick\",\n    extras={\"help\": \"Removes the target member from the guild\"}\n)\nasync def kick_member(...):\n\"\"\"Kick a member from the server\"\"\"\n</code></pre>"},{"location":"#support-for-commands-checks","title":"Support for <code>@commands</code> Checks","text":"<p>The <code>helply</code> library also supports parsing of <code>@commands</code> style checks. For instance, if you are using <code>@commands.has_permissions()</code> to restrict command usage, the extension will recognize and display these permission requirements in the help response.</p> <p>Example: <pre><code>@bot.slash_command(name=\"kick\")\n@commands.has_permissions(kick_members=True)\nasync def kick_member(inter: disnake.GuildCommandInteraction, member: disnake.Member):\n\"\"\"Kick a member from the server\n\n    Parameters\n    ----------\n    member: Select a member to kick\n    \"\"\"\n</code></pre> </p>"},{"location":"#cogs-categories-and-disnake-ext-plugin-support","title":"Cogs, Categories, and disnake-ext-plugin support","text":"<p><code>Helply</code> is able to parse the cog or category a command belongs to.  This is useful if you wish to display an overview of command available within a category.  If you are using cogs, you do not have to do anything extra.  The cog associated with a command will be parsed automatically. However, if you're using disnake-ext-plugins, a command's cog will always be None.  So, to set a commands category, we go back to the <code>extras</code> keyword to set the command's category:</p> <pre><code>@some_plugin.slash_command(name='command', extras={\"category\": \"General\"})\nasync def some_command(inter: disnake.ApplicationCommandInteractions):\n    ...\n</code></pre>"},{"location":"#filtering-commands","title":"Filtering Commands","text":"<p>When retrieving commands from <code>Helply</code>, you may choose to pass in a member's <code>guild_permissions</code>. This will ensure that only commands the user has permissions to use will be retrieved.</p> <p>Here, if the command is used within a guild, we want to show all commands available within the guild, including global commands, and only commands that the inter.author is able to use.</p> <p>Important</p> <p>Permissions are compared against <code>default_member_permissions</code>.  Setting this by default hides commands from members unable to use them, Passing permissions also allows <code>Helply</code> to ensure these commands stay hidden in help responses.</p> <pre><code># construct Helply with the provided bot and a sequence of commands to ignore\n# ignored commands will not appear in any help responses.\nhelply = Helply(bot, commands_to_ignore=('help',))\n\n@bot.slash_command(name='help')\nasync def help_command(inter: disnake.ApplicationCommandInteraction):\n\n    if inter.guild:\n        guild_id = inter.guild_id\n        permissions = inter.author.guild_permissions\n        dm_only = False\n    else:\n        # command likely used in direct message\n        guild_id = None\n        permissions = None\n        dm_only = True\n\n    commands = helply.get_commands(\n        guild_id, permissions=permissions, dm_only=dm_only, locale=inter.locale\n    )\n</code></pre>"},{"location":"#support","title":"Support","text":"<p>Join the discord to get support or just chat.</p>"},{"location":"license/","title":"MIT License","text":"<p>Copyright (c) 2023 DLCHAMP</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>helply<ul> <li>helply</li> <li>types<ul> <li>argument</li> <li>checks</li> <li>commands</li> <li>enums</li> </ul> </li> <li>utils<ul> <li>embeds</li> <li>paginator</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/helply/helply/","title":"helply","text":""},{"location":"reference/helply/helply/#helply.helply--helply","title":"Helply","text":"<p>Handles the creation and storing of the app commands and provides the methods to retrive them</p>"},{"location":"reference/helply/helply/#helply.helply.Helply","title":"<code>Helply</code>","text":"<p>Represents an application command helper.</p> <p>Parameters:</p> <ul> <li> bot             (<code>Union[Bot, InteractionBot]</code>)         \u2013          <p>The bot for which this help class will be associated with.</p> </li> <li> commands_to_ignore             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>Provide a list of command names to ignore when walking all app commands.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>class Helply:\n\"\"\"Represents an application command helper.\n\n    Parameters\n    ----------\n    bot : Union[commands.Bot, commands.InteractionBot]\n        The bot for which this help class will be associated with.\n    commands_to_ignore: Iterable[str]\n        Provide a list of command names to ignore when walking all app commands.\n    \"\"\"\n\n    __slots__ = (\n        \"bot\",\n        \"commands_to_ignore\",\n        \"_app_commands\",\n    )\n\n    def __init__(self, bot: Bot, commands_to_ignore: Optional[Sequence[str]] = None) -&gt; None:\n        self.bot = bot\n\n        if commands_to_ignore is not None:\n            self.commands_to_ignore: set[str] = set(commands_to_ignore)\n        else:\n            self.commands_to_ignore = set()\n\n        self._app_commands: List[AppCommand] = []\n\n    def _get_command_args(\n        self, command: Union[disnake.APISlashCommand, disnake.Option]\n    ) -&gt; List[Argument]:\n\"\"\"Parse and return the `SlashCommand` or `SubCommand` arguments.\n\n        Parameters\n        ----------\n        command : Union[disnake.APISlashCommand, disnake.Option]\n            The slash command or a slash command's sub_command.\n\n        Returns\n        -------\n        List[Argument]\n            A sequence of the command or sub_command's arguments.\n        \"\"\"\n        args: List[Argument] = []\n        for option in command.options:\n            if option.type in (\n                disnake.OptionType.sub_command,\n                disnake.OptionType.sub_command_group,\n            ):\n                continue\n\n            args.append(\n                Argument(\n                    name=option.name,\n                    name_localizations=option.name_localizations,\n                    description=option.description,\n                    description_localizations=option.description_localizations,\n                    required=option.required,\n                )\n            )\n\n        return args\n\n    def _get_command_desc(\n        self,\n        command: commands.InvokableApplicationCommand,\n    ) -&gt; str:\n\"\"\"Get the description for a command.\n\n        Parameters\n        ----------\n        command: commands.InvokableSlashCommand,\n            The invokable command to parse descriptions from\n\n        Returns\n        -------\n        str\n            The description of the command.\n        \"\"\"\n        extras = command.extras.get(\"help\")\n        description = getattr(command, \"description\", \"-\")\n\n        return extras or description\n\n    def _parse_cooldowns(\n        self,\n        command: Union[commands.InvokableApplicationCommand, commands.SubCommand],\n    ) -&gt; Optional[Cooldown]:\n\"\"\"Parse the configured cooldown for an ApplicationCommand.\n\n        Parameters\n        ----------\n        command: Union[commands.InvokableApplicationCommand, commands.SubCommand]\n            The application command to parse cooldowns from.\n\n        Returns\n        -------\n        Optional[Cooldown]\n            Return the Cooldown if configured, else None\n        \"\"\"\n        cooldown = command._buckets._cooldown  # type: ignore\n        if cooldown is None:\n            return None\n\n        rate = cooldown.rate\n        per = cooldown.per\n        type_ = str(command._buckets._type)  # type: ignore\n\n        type_ = type_.replace(\"BucketType.\", \"\").title()\n\n        return Cooldown(rate=rate, per=per, type=type_)\n\n    def _get_sub_commands(\n        self,\n        command: Union[disnake.APISlashCommand, disnake.Option],\n        checks: CommandChecks,\n        category: str,\n        parent_command: Optional[disnake.APISlashCommand] = None,\n    ) -&gt; List[SlashCommand]:\n\"\"\"Get and return the `APISlashCommand`'s registered `SubCommands` if any.\n\n        Parameters\n        ----------\n        command : Union[disnake.APISlashCommand, disnake.Option]\n            The registered slash command or the command's SubCommand.\n        checks : CommandChecks\n            The permission and role checks assigned to the parent command.\n        category : str\n            The category of the commands.\n        parent_command : Optional[disnake.APISlashCommand]\n            Parent command. Only used if sub_group is used and this function is called\n            recursively.\n\n        Returns\n        -------\n        List[SlashCommand]\n            A list of sub-commands, if any.\n        \"\"\"\n        sub_commands: List[SlashCommand] = []\n\n        # ensure we always have access to the original parent command.\n        if parent_command is None and isinstance(command, disnake.APISlashCommand):\n            original_command = command\n        elif parent_command:\n            original_command = parent_command\n        else:\n            msg = (\n                \"Invalid input. Either command must be an instance of `disnake.APISlashCommand\"\n                \"or parent_command must be provided.\"\n            )\n            raise ValueError(msg)\n\n        for option in command.options:\n            name = (\n                f\"{original_command.name} {command.name} {option.name}\"\n                if parent_command\n                else f\"{original_command.name} {option.name}\"\n            )\n            if option.type == disnake.OptionType.sub_command_group:\n                sub_commands.extend(\n                    self._get_sub_commands(option, checks, category, original_command)\n                )\n\n            elif option.type == disnake.OptionType.sub_command:\n                args = self._get_command_args(option)\n                command_id = original_command.id\n                dm_permissions = original_command.dm_permission\n                nsfw = original_command.nsfw\n\n                invokable = self.bot.get_slash_command(name)\n                if not invokable:\n                    return []\n                desc = self._get_command_desc(invokable)\n                cooldown = self._parse_cooldowns(invokable)\n                sub_commands.append(\n                    SlashCommand(\n                        id=command_id,\n                        name=name,\n                        name_=name,\n                        description=desc,\n                        name_localizations=original_command.name_localizations,\n                        description_localizations=original_command.description_localizations,\n                        args=args,\n                        checks=checks,\n                        type=AppCommandType.SLASH,\n                        dm_permission=dm_permissions,\n                        nsfw=nsfw,\n                        cooldown=cooldown,\n                        category=category,\n                    )\n                )\n\n        return sub_commands\n\n    def _parse_checks(\n        self,\n        command: commands.InvokableApplicationCommand,\n    ) -&gt; CommandChecks:\n\"\"\"Parse the checks associated with a command and extract registered permissions and roles.\n\n        Parameters\n        ----------\n        command : commands.InvokableApplicationCommand\n            The command object to parse checks from.\n\n        Returns\n        -------\n        CommandChecks\n            A NamedTuple containing a list of permissions and/or role names or IDs\n            required to invoke the command.\n        \"\"\"\n        permissions: List[str] = []\n        roles: List[Union[str, int]] = []\n\n        # command.checks provides a list of check predicates\n        # associated with the command\n        checks = command.checks\n\n        # iterate those checks and analyze them to access\n        # check names (ie. \"has_any_role\")\n        for check in checks:\n            name = check.__qualname__.split(\".\")[0]\n            if \"bot\" in name or not check.__closure__:\n                continue\n\n            # for each check that does not include \"bot\" (ie. \"bot_has_permissions\")\n            # the arguments will be parsed and used to populate `CommandChecks`\n            closure = check.__closure__[0]\n\n            args = (\n                closure.cell_contents\n                if len(closure.cell_contents) &gt; 1\n                else (closure.cell_contents,)\n            )\n\n            # checks pertaining to roles will populate CommandChecks.roles\n            if \"role\" in name:\n                roles.extend(args)\n\n            # remaining checks should be permissions based and are formatted\n            # then added to CommandChecks.permissions\n            else:\n                permissions.extend(\n                    [p.replace(\"_\", \" \").title() for p, v in closure.cell_contents.items() if v]\n                )\n\n        return CommandChecks(permissions, roles)\n\n    def _handle_slash_command(self, command: disnake.APISlashCommand) -&gt; List[SlashCommand]:\n\"\"\"Handle creation of `SlashCommand` from `disnake.APISlashCommand`.\n\n        Parameters\n        ----------\n        command : disnake.APISlashCommand\n            The APISlashCommand provided by Discord's API.\n\n        Return\n        ------\n        List[SlashCommand]\n            The constructed `SlashCommand`.\n        \"\"\"\n        invokable = self.bot.get_slash_command(command.name)\n        if invokable is None:\n            return []\n\n        checks = self._parse_checks(invokable)\n        cooldown = self._parse_cooldowns(invokable)\n        desc = self._get_command_desc(invokable)\n        category = self._get_command_category(invokable)\n        args = self._get_command_args(command)\n        sub_commands = self._get_sub_commands(command, checks, category)\n\n        if sub_commands:\n            return sub_commands\n\n        return [\n            SlashCommand(\n                id=command.id,\n                name=command.name,\n                name_=command.name,\n                description=desc,\n                name_localizations=command.name_localizations,\n                description_localizations=command.description_localizations,\n                args=args,\n                checks=checks,\n                type=AppCommandType.SLASH,\n                dm_permission=command.dm_permission,\n                nsfw=command.nsfw,\n                cooldown=cooldown,\n                guild_id=command.guild_id,\n                default_member_permissions=invokable.default_member_permissions,\n                category=category,\n            )\n        ]\n\n    def _handle_message_command(\n        self, command: disnake.APIMessageCommand\n    ) -&gt; Optional[MessageCommand]:\n\"\"\"Handle creation of `MessageCommand` from `disnake.APIMessageCommand`.\n\n        Parameters\n        ----------\n        command : disnake.APIUserCommand\n            The APIMessageCommand provided by Discord's API.\n\n        Return\n        ------\n        Optional[MessageCommand]\n            The constructed `MessageCommand`.\n        \"\"\"\n        invokable = self.bot.get_message_command(command.name)\n        if invokable is None:\n            return invokable\n\n        checks = self._parse_checks(invokable)\n        cooldown = self._parse_cooldowns(invokable)\n        desc = invokable.extras.get(\"help\", \"-\")\n        category = self._get_command_category(invokable)\n\n        return MessageCommand(\n            id=command.id,\n            name=command.name,\n            name_=command.name,\n            description=desc,\n            name_localizations=command.name_localizations,\n            checks=checks,\n            type=AppCommandType.MESSAGE,\n            dm_permission=command.dm_permission,\n            nsfw=command.nsfw,\n            cooldown=cooldown,\n            guild_id=command.guild_id,\n            default_member_permissions=invokable.default_member_permissions,\n            category=category,\n        )\n\n    def _handle_user_command(self, command: disnake.APIUserCommand) -&gt; Optional[UserCommand]:\n\"\"\"Handle creation of `UserCommand` from `disnake.APIUserCommand`.\n\n        Parameters\n        ----------\n        command : disnake.APIUserCommand\n            The APIUserCommand provided by Discord's API.\n\n        Return\n        ------\n        Optional[UserCommand]\n            The constructed `UserCommand`.\n        \"\"\"\n        invokable = self.bot.get_user_command(command.name)\n\n        if invokable is None:\n            return invokable\n\n        checks = self._parse_checks(invokable)\n        cooldown = self._parse_cooldowns(invokable)\n        desc = invokable.extras.get(\"help\", \"-\")\n        category = self._get_command_category(invokable)\n\n        return UserCommand(\n            id=command.id,\n            name=command.name,\n            name_=command.name,\n            description=desc,\n            name_localizations=command.name_localizations,\n            checks=checks,\n            type=AppCommandType.USER,\n            dm_permission=command.dm_permission,\n            nsfw=command.nsfw,\n            cooldown=cooldown,\n            guild_id=command.guild_id,\n            default_member_permissions=invokable.default_member_permissions,\n            category=category,\n        )\n\n    def _get_command_category(self, invokable: commands.InvokableApplicationCommand) -&gt; str:\n\"\"\"Get the command's cog or category name, if available\n\n        `cog_name` would be derived from `disnake.ext.commands.Cog`, whereas\n        `category` would come from setting extras if you're using something like\n        [disnake-ext-plugins](https://github.com/DisnakeCommunity/disnake-ext-plugins)\n\n        Parameters\n        ----------\n        invokable: commands.InvokableApplicationCommand\n\n        Returns\n        -------\n        str\n            Command's cog_name or value of extras['category'], else \"None\"\n\n        \"\"\"\n        name = invokable.cog_name or invokable.extras.get(\"category\")\n        if not name:\n            name = \"None\"\n\n        return name\n\n    def _walk_app_commands(self) -&gt; None:\n\"\"\"Retrieve all global and guild-specific application commands.\"\"\"\n        all_commands = self.bot.global_application_commands\n        for guild in self.bot.guilds:\n            all_commands.extend(self.bot.get_guild_application_commands(guild.id))\n\n        for command in all_commands:\n            if self.commands_to_ignore and command.name in self.commands_to_ignore:\n                continue\n\n            if isinstance(command, disnake.APISlashCommand):\n                self._app_commands.extend(self._handle_slash_command(command))\n\n            elif isinstance(command, disnake.MessageCommand):\n                msg_command = self._handle_message_command(command)\n\n                if msg_command:\n                    self._app_commands.append(msg_command)\n\n            else:\n                user_command = self._handle_user_command(command)\n\n                if user_command:\n                    self._app_commands.append(user_command)\n\n    def get_all_commands(\n        self,\n        guild_id: Optional[int] = None,\n        *,\n        category: Optional[str] = None,\n        permissions: Optional[disnake.Permissions] = None,\n        include_nsfw: bool = True,\n        dm_only: bool = False,\n        locale: Optional[disnake.Locale] = None,\n    ) -&gt; List[AppCommand]:\n\"\"\"Retrieve a filtered list of AppCommand based on specified criteria.\n\n        By default, this method should return all registered commands. Specify filters\n        to narrow down the output results.\n\n        !!! Warning\n            This method is deprecated as of *version 0.4.0* and will be replaced by it's current\n            alias `get_commands`.\n\n        Parameters\n        ----------\n        guild_id : Optional[int]\n            Filter commands registered to the specified guild_id.  If not specified,\n            all commands may be returned.\n        category: Optional[str]\n            Filter commands by only a specified category\n        permissions: Optional[disnake.Permissions]\n            Filter commands that do not exceed permissions. If not specified,\n            commands will not be filtered by permissions.\n            !!! Note\n                Should not be used with `dm_only`\n        include_nsfw : bool\n            Whether or not to include categories NSFW commands.\n        dm_only: bool\n            Whether or not to include only commands with direct message enabled.\n            !!! Note\n                Should not specify `guild_id` or `permissions` if setting this to True\n        locale: Optional[disnake.Locale]\n            Specify locale to get localized commands and arguments, where available.\n\n        Returns\n        -------\n        List[AppCommand]\n            Resulting list of `AppCommand`. If locale is specified, the command will be returned\n            with localized attributes.\n        \"\"\"\n        if not self._app_commands:\n            self._walk_app_commands()\n\n        commands: List[AppCommand] = []\n\n        for command in self._app_commands:\n            if category and command.category != category:\n                continue\n\n            if guild_id and command.guild_id and command.guild_id != guild_id:\n                continue\n\n            if dm_only and not command.dm_permission:\n                continue\n\n            if not permissions and command.default_member_permissions:\n                continue\n\n            if (\n                permissions\n                and command.default_member_permissions\n                and not permissions &gt;= command.default_member_permissions\n            ):\n                continue\n\n            if not include_nsfw and command.nsfw:\n                continue\n\n            if locale:\n                command = command.localize(locale)  # noqa: PLW2901\n\n            if command not in commands:\n                commands.append(command)\n\n        return commands\n\n    # temporary alias - get_all_commands will be removed, eventually\n    get_commands = get_all_commands\n\n    def get_command_named(\n        self,\n        name: str,\n        locale: Optional[disnake.Locale] = None,\n        cmd_type: Optional[AppCommandType] = None,\n    ) -&gt; Optional[AppCommand]:\n\"\"\"Get a command by its name.\n\n        !!! Warning\n            When passing a locale, the provided name needs to match the localized name.\n            This works best when receiving a command name from autocomplete.\n\n        Parameters\n        ----------\n        name : str\n            Name of the ApplicationCommand.\n        locale: Optional[disnake.Locale]\n            Specify locale to get a localized command and arguments.\n        cmd_type: Optional[AppCommandType]\n            Specify the type of command to be returned. If not specified, the first matching\n            command will be returned regardless of its type.\n\n\n        Returns\n        -------\n        Optional[AppCommand]\n            The command that matches the provided name and type, if available.\n        \"\"\"\n        for command in self._app_commands:\n            if command.name == name and (cmd_type is None or command.type is cmd_type):\n                if locale:\n                    return command.localize(locale)\n\n                return command\n\n    def get_commands_by_category(\n        self,\n        category: str,\n        *,\n        locale: Optional[disnake.Locale] = None,\n        guild_id: Optional[int] = None,\n        permissions: Optional[disnake.Permissions] = None,\n        include_nsfw: bool = True,\n        dm_only: bool = False,\n    ) -&gt; List[AppCommand]:\n\"\"\"Retrieve a list of AppCommands within a category\n\n        By default, this method should return all registered commands within a category.\n        Specify filters to narrow down the output results.\n\n        Parameters\n        ----------\n        category: str\n            Category for which commands are in.\n        locale: Optional[disnake.Locale]\n            Include locale to get localized commands.\n        guild_id : Optional[int]\n            Filter commands registered to the specified guild_id.  If not specified,\n            all commands may be returned.\n        permissions: Optional[disnake.Permissions]\n            Filter commands that do not exceed permissions. If not specified,\n            commands will not be filtered by permissions.\n            !!! Note\n                Should not be used with `dm_only`\n        include_nsfw : bool\n            Whether or not to include categories NSFW commands.\n        dm_only: bool\n            Whether or not to include only commands with direct message enabled.\n            !!! Note\n                Should not specify `guild_id` or `permissions` if setting this to True\n\n        Returns\n        -------\n        List[AppCommand]\n            A list of commands within the specified category name.\n\n        \"\"\"\n        return self.get_all_commands(\n            guild_id,\n            category=category,\n            permissions=permissions,\n            include_nsfw=include_nsfw,\n            dm_only=dm_only,\n            locale=locale,\n        )\n\n    def get_categories(\n        self,\n        guild_id: Optional[int] = None,\n        *,\n        permissions: Optional[disnake.Permissions] = None,\n        include_nsfw: bool = True,\n        dm_only: bool = False,\n    ) -&gt; List[str]:\n\"\"\"Return a unique list of command categories.\n\n        Useful if you wish to have an autocomplete for users to select from available\n        command categories.\n\n        Parameters\n        ----------\n        guild_id : Optional[int]\n            Filter categories with commands registered to the specified guild_id. If not\n            specified, all categories may be returned.\n        permissions: Optional[disnake.Permissions]\n            Filter commands that do not exceed permissions. If not specified,\n            commands will not be filtered by permissions.\n            !!! Note\n                Should not be used with `dm_only`\n        include_nsfw : bool\n            Whether or not to include categories NSFW commands.\n        dm_only: bool\n            Whether or not to include only commands with direct message enabled.\n            !!! Note\n                Should not specify `guild_id` or `permissions` if setting this to True\n\n        Example:\n        ```python\n        @some_command.autocomplete('category')\n        async def some_command_group_autocomplete(\n            inter: disnake.ApplicationCommandInteraction, string: str\n        ) -&gt; List[str]:\n            string = string.casefold()\n            commands = helper.get_command_categories(inter.guild.id)\n            return [g for g in commands if string in g.casefold()]\n        ```\n\n        Returns\n        -------\n        List[str]\n            A list of unique command categories.\n        \"\"\"\n        categories: List[str] = []\n\n        for command in self.get_all_commands(\n            guild_id,\n            permissions=permissions,\n            include_nsfw=include_nsfw,\n            dm_only=dm_only,\n        ):\n            if command.category not in categories:\n                categories.append(command.category)\n\n        return categories\n\n    def get_dm_only_commands(\n        self,\n        *,\n        include_nsfw: bool = False,\n        locale: Optional[disnake.Locale] = None,\n    ) -&gt; List[AppCommand]:\n\"\"\"Return only commands with dm_permission set to True.\n\n        Parameters\n        ----------\n        include_nsfw: bool\n            Whether or not to include NSFW commands.\n        locale: Optional[disnake.Locale]\n            Include local to get localized commands.\n\n\n        Returns\n        -------\n        List[AppCommand]\n            A list of AppCommand where dm_permission is True.\n        \"\"\"\n        return self.get_all_commands(dm_only=True, locale=locale, include_nsfw=include_nsfw)\n\n    def get_guild_commands(\n        self,\n        guild_id: int,\n        *,\n        include_nsfw: bool = False,\n        permissions: Optional[disnake.Permissions] = None,\n        locale: Optional[disnake.Locale] = None,\n    ) -&gt; List[AppCommand]:\n\"\"\"Return commands where guild_id is None or guild_id matches specified guild_id.\n\n        !!! Note\n            Including `permissions` will restrict the command list to prevent commands hidden by\n            default_command_permissions from appearing to the command author.\n\n        Parameters\n        ----------\n        guild_id: int\n            ID for the guild for which guild-specific command are registered.\n        include_nsfw: bool\n            Whether or not to include NSFW commands.\n        permissions: Optional[disnake.Permissions]\n            Set the permission limit of the resulting commands.  Any commands that exceed specified\n            permissions will be omitted\n        locale: Optional[disnake.Locale]\n            Specify locale to get localized commands and arguments.\n\n        Returns\n        -------\n        List[AppCommand]\n            A list of AppCommand where guild_id is not specified (global) or guild_id matches\n            the specified guild_id.\n        \"\"\"\n        return self.get_all_commands(\n            guild_id, locale=locale, include_nsfw=include_nsfw, permissions=permissions\n        )\n\n    @staticmethod\n    def roles_from_checks(checks: CommandChecks, guild: disnake.Guild) -&gt; List[disnake.Role]:\n\"\"\"Parse the command's role checks and return a list of `disnake.Role`.\n\n        Parameters\n        ----------\n        checks : CommandChecks\n            A command's checks\n\n        Returns\n        -------\n        List[disnake.Role]\n            `Roles` that have been successfully converted from name or ID.\n        \"\"\"\n        role_checks = checks.roles\n        roles: List[disnake.Role] = []\n\n        for name_or_id in role_checks:\n            if isinstance(name_or_id, int) or name_or_id.isdigit():\n                role = guild.get_role(int(name_or_id))\n            else:\n                role = disnake.utils.get(guild.roles, name=name_or_id)\n\n            if role:\n                roles.append(role)\n\n        return roles\n</code></pre>"},{"location":"reference/helply/helply/#helply.helply.Helply.get_all_commands","title":"<code>get_all_commands(guild_id=None, *, category=None, permissions=None, include_nsfw=True, dm_only=False, locale=None)</code>","text":"<p>Retrieve a filtered list of AppCommand based on specified criteria.</p> <p>By default, this method should return all registered commands. Specify filters to narrow down the output results.</p> <p>Warning</p> <p>This method is deprecated as of version 0.4.0 and will be replaced by it's current alias <code>get_commands</code>.</p> <p>Parameters:</p> <ul> <li> guild_id             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Filter commands registered to the specified guild_id.  If not specified, all commands may be returned.</p> </li> <li> category             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Filter commands by only a specified category</p> </li> <li> permissions             (<code>Optional[Permissions]</code>, default:                 <code>None</code> )         \u2013          <p>Filter commands that do not exceed permissions. If not specified, commands will not be filtered by permissions.</p> <p>Note</p> <p>Should not be used with <code>dm_only</code></p> </li> <li> include_nsfw             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether or not to include categories NSFW commands.</p> </li> <li> dm_only             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to include only commands with direct message enabled.</p> <p>Note</p> <p>Should not specify <code>guild_id</code> or <code>permissions</code> if setting this to True</p> </li> <li> locale             (<code>Optional[Locale]</code>, default:                 <code>None</code> )         \u2013          <p>Specify locale to get localized commands and arguments, where available.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[AppCommand]</code>         \u2013          <p>Resulting list of <code>AppCommand</code>. If locale is specified, the command will be returned with localized attributes.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>def get_all_commands(\n    self,\n    guild_id: Optional[int] = None,\n    *,\n    category: Optional[str] = None,\n    permissions: Optional[disnake.Permissions] = None,\n    include_nsfw: bool = True,\n    dm_only: bool = False,\n    locale: Optional[disnake.Locale] = None,\n) -&gt; List[AppCommand]:\n\"\"\"Retrieve a filtered list of AppCommand based on specified criteria.\n\n    By default, this method should return all registered commands. Specify filters\n    to narrow down the output results.\n\n    !!! Warning\n        This method is deprecated as of *version 0.4.0* and will be replaced by it's current\n        alias `get_commands`.\n\n    Parameters\n    ----------\n    guild_id : Optional[int]\n        Filter commands registered to the specified guild_id.  If not specified,\n        all commands may be returned.\n    category: Optional[str]\n        Filter commands by only a specified category\n    permissions: Optional[disnake.Permissions]\n        Filter commands that do not exceed permissions. If not specified,\n        commands will not be filtered by permissions.\n        !!! Note\n            Should not be used with `dm_only`\n    include_nsfw : bool\n        Whether or not to include categories NSFW commands.\n    dm_only: bool\n        Whether or not to include only commands with direct message enabled.\n        !!! Note\n            Should not specify `guild_id` or `permissions` if setting this to True\n    locale: Optional[disnake.Locale]\n        Specify locale to get localized commands and arguments, where available.\n\n    Returns\n    -------\n    List[AppCommand]\n        Resulting list of `AppCommand`. If locale is specified, the command will be returned\n        with localized attributes.\n    \"\"\"\n    if not self._app_commands:\n        self._walk_app_commands()\n\n    commands: List[AppCommand] = []\n\n    for command in self._app_commands:\n        if category and command.category != category:\n            continue\n\n        if guild_id and command.guild_id and command.guild_id != guild_id:\n            continue\n\n        if dm_only and not command.dm_permission:\n            continue\n\n        if not permissions and command.default_member_permissions:\n            continue\n\n        if (\n            permissions\n            and command.default_member_permissions\n            and not permissions &gt;= command.default_member_permissions\n        ):\n            continue\n\n        if not include_nsfw and command.nsfw:\n            continue\n\n        if locale:\n            command = command.localize(locale)  # noqa: PLW2901\n\n        if command not in commands:\n            commands.append(command)\n\n    return commands\n</code></pre>"},{"location":"reference/helply/helply/#helply.helply.Helply.get_categories","title":"<code>get_categories(guild_id=None, *, permissions=None, include_nsfw=True, dm_only=False)</code>","text":"<p>Return a unique list of command categories.</p> <p>Useful if you wish to have an autocomplete for users to select from available command categories.</p> <p>Parameters:</p> <ul> <li> guild_id             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Filter categories with commands registered to the specified guild_id. If not specified, all categories may be returned.</p> </li> <li> permissions             (<code>Optional[Permissions]</code>, default:                 <code>None</code> )         \u2013          <p>Filter commands that do not exceed permissions. If not specified, commands will not be filtered by permissions.</p> <p>Note</p> <p>Should not be used with <code>dm_only</code></p> </li> <li> include_nsfw             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether or not to include categories NSFW commands.</p> </li> <li> dm_only             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to include only commands with direct message enabled.</p> <p>Note</p> <p>Should not specify <code>guild_id</code> or <code>permissions</code> if setting this to True</p> </li> </ul> <p>Example: <pre><code>@some_command.autocomplete('category')\nasync def some_command_group_autocomplete(\n    inter: disnake.ApplicationCommandInteraction, string: str\n) -&gt; List[str]:\n    string = string.casefold()\n    commands = helper.get_command_categories(inter.guild.id)\n    return [g for g in commands if string in g.casefold()]\n</code></pre></p> <p>Returns:</p> <ul> <li> <code>List[str]</code>         \u2013          <p>A list of unique command categories.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>def get_categories(\n    self,\n    guild_id: Optional[int] = None,\n    *,\n    permissions: Optional[disnake.Permissions] = None,\n    include_nsfw: bool = True,\n    dm_only: bool = False,\n) -&gt; List[str]:\n\"\"\"Return a unique list of command categories.\n\n    Useful if you wish to have an autocomplete for users to select from available\n    command categories.\n\n    Parameters\n    ----------\n    guild_id : Optional[int]\n        Filter categories with commands registered to the specified guild_id. If not\n        specified, all categories may be returned.\n    permissions: Optional[disnake.Permissions]\n        Filter commands that do not exceed permissions. If not specified,\n        commands will not be filtered by permissions.\n        !!! Note\n            Should not be used with `dm_only`\n    include_nsfw : bool\n        Whether or not to include categories NSFW commands.\n    dm_only: bool\n        Whether or not to include only commands with direct message enabled.\n        !!! Note\n            Should not specify `guild_id` or `permissions` if setting this to True\n\n    Example:\n    ```python\n    @some_command.autocomplete('category')\n    async def some_command_group_autocomplete(\n        inter: disnake.ApplicationCommandInteraction, string: str\n    ) -&gt; List[str]:\n        string = string.casefold()\n        commands = helper.get_command_categories(inter.guild.id)\n        return [g for g in commands if string in g.casefold()]\n    ```\n\n    Returns\n    -------\n    List[str]\n        A list of unique command categories.\n    \"\"\"\n    categories: List[str] = []\n\n    for command in self.get_all_commands(\n        guild_id,\n        permissions=permissions,\n        include_nsfw=include_nsfw,\n        dm_only=dm_only,\n    ):\n        if command.category not in categories:\n            categories.append(command.category)\n\n    return categories\n</code></pre>"},{"location":"reference/helply/helply/#helply.helply.Helply.get_command_named","title":"<code>get_command_named(name, locale=None, cmd_type=None)</code>","text":"<p>Get a command by its name.</p> <p>Warning</p> <p>When passing a locale, the provided name needs to match the localized name. This works best when receiving a command name from autocomplete.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>Name of the ApplicationCommand.</p> </li> <li> locale             (<code>Optional[Locale]</code>, default:                 <code>None</code> )         \u2013          <p>Specify locale to get a localized command and arguments.</p> </li> <li> cmd_type             (<code>Optional[AppCommandType]</code>, default:                 <code>None</code> )         \u2013          <p>Specify the type of command to be returned. If not specified, the first matching command will be returned regardless of its type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[AppCommand]</code>         \u2013          <p>The command that matches the provided name and type, if available.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>def get_command_named(\n    self,\n    name: str,\n    locale: Optional[disnake.Locale] = None,\n    cmd_type: Optional[AppCommandType] = None,\n) -&gt; Optional[AppCommand]:\n\"\"\"Get a command by its name.\n\n    !!! Warning\n        When passing a locale, the provided name needs to match the localized name.\n        This works best when receiving a command name from autocomplete.\n\n    Parameters\n    ----------\n    name : str\n        Name of the ApplicationCommand.\n    locale: Optional[disnake.Locale]\n        Specify locale to get a localized command and arguments.\n    cmd_type: Optional[AppCommandType]\n        Specify the type of command to be returned. If not specified, the first matching\n        command will be returned regardless of its type.\n\n\n    Returns\n    -------\n    Optional[AppCommand]\n        The command that matches the provided name and type, if available.\n    \"\"\"\n    for command in self._app_commands:\n        if command.name == name and (cmd_type is None or command.type is cmd_type):\n            if locale:\n                return command.localize(locale)\n\n            return command\n</code></pre>"},{"location":"reference/helply/helply/#helply.helply.Helply.get_commands_by_category","title":"<code>get_commands_by_category(category, *, locale=None, guild_id=None, permissions=None, include_nsfw=True, dm_only=False)</code>","text":"<p>Retrieve a list of AppCommands within a category</p> <p>By default, this method should return all registered commands within a category. Specify filters to narrow down the output results.</p> <p>Parameters:</p> <ul> <li> category             (<code>str</code>)         \u2013          <p>Category for which commands are in.</p> </li> <li> locale             (<code>Optional[Locale]</code>, default:                 <code>None</code> )         \u2013          <p>Include locale to get localized commands.</p> </li> <li> guild_id             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Filter commands registered to the specified guild_id.  If not specified, all commands may be returned.</p> </li> <li> permissions             (<code>Optional[Permissions]</code>, default:                 <code>None</code> )         \u2013          <p>Filter commands that do not exceed permissions. If not specified, commands will not be filtered by permissions.</p> <p>Note</p> <p>Should not be used with <code>dm_only</code></p> </li> <li> include_nsfw             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether or not to include categories NSFW commands.</p> </li> <li> dm_only             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to include only commands with direct message enabled.</p> <p>Note</p> <p>Should not specify <code>guild_id</code> or <code>permissions</code> if setting this to True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[AppCommand]</code>         \u2013          <p>A list of commands within the specified category name.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>def get_commands_by_category(\n    self,\n    category: str,\n    *,\n    locale: Optional[disnake.Locale] = None,\n    guild_id: Optional[int] = None,\n    permissions: Optional[disnake.Permissions] = None,\n    include_nsfw: bool = True,\n    dm_only: bool = False,\n) -&gt; List[AppCommand]:\n\"\"\"Retrieve a list of AppCommands within a category\n\n    By default, this method should return all registered commands within a category.\n    Specify filters to narrow down the output results.\n\n    Parameters\n    ----------\n    category: str\n        Category for which commands are in.\n    locale: Optional[disnake.Locale]\n        Include locale to get localized commands.\n    guild_id : Optional[int]\n        Filter commands registered to the specified guild_id.  If not specified,\n        all commands may be returned.\n    permissions: Optional[disnake.Permissions]\n        Filter commands that do not exceed permissions. If not specified,\n        commands will not be filtered by permissions.\n        !!! Note\n            Should not be used with `dm_only`\n    include_nsfw : bool\n        Whether or not to include categories NSFW commands.\n    dm_only: bool\n        Whether or not to include only commands with direct message enabled.\n        !!! Note\n            Should not specify `guild_id` or `permissions` if setting this to True\n\n    Returns\n    -------\n    List[AppCommand]\n        A list of commands within the specified category name.\n\n    \"\"\"\n    return self.get_all_commands(\n        guild_id,\n        category=category,\n        permissions=permissions,\n        include_nsfw=include_nsfw,\n        dm_only=dm_only,\n        locale=locale,\n    )\n</code></pre>"},{"location":"reference/helply/helply/#helply.helply.Helply.get_dm_only_commands","title":"<code>get_dm_only_commands(*, include_nsfw=False, locale=None)</code>","text":"<p>Return only commands with dm_permission set to True.</p> <p>Parameters:</p> <ul> <li> include_nsfw             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to include NSFW commands.</p> </li> <li> locale             (<code>Optional[Locale]</code>, default:                 <code>None</code> )         \u2013          <p>Include local to get localized commands.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[AppCommand]</code>         \u2013          <p>A list of AppCommand where dm_permission is True.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>def get_dm_only_commands(\n    self,\n    *,\n    include_nsfw: bool = False,\n    locale: Optional[disnake.Locale] = None,\n) -&gt; List[AppCommand]:\n\"\"\"Return only commands with dm_permission set to True.\n\n    Parameters\n    ----------\n    include_nsfw: bool\n        Whether or not to include NSFW commands.\n    locale: Optional[disnake.Locale]\n        Include local to get localized commands.\n\n\n    Returns\n    -------\n    List[AppCommand]\n        A list of AppCommand where dm_permission is True.\n    \"\"\"\n    return self.get_all_commands(dm_only=True, locale=locale, include_nsfw=include_nsfw)\n</code></pre>"},{"location":"reference/helply/helply/#helply.helply.Helply.get_guild_commands","title":"<code>get_guild_commands(guild_id, *, include_nsfw=False, permissions=None, locale=None)</code>","text":"<p>Return commands where guild_id is None or guild_id matches specified guild_id.</p> <p>Note</p> <p>Including <code>permissions</code> will restrict the command list to prevent commands hidden by default_command_permissions from appearing to the command author.</p> <p>Parameters:</p> <ul> <li> guild_id             (<code>int</code>)         \u2013          <p>ID for the guild for which guild-specific command are registered.</p> </li> <li> include_nsfw             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether or not to include NSFW commands.</p> </li> <li> permissions             (<code>Optional[Permissions]</code>, default:                 <code>None</code> )         \u2013          <p>Set the permission limit of the resulting commands.  Any commands that exceed specified permissions will be omitted</p> </li> <li> locale             (<code>Optional[Locale]</code>, default:                 <code>None</code> )         \u2013          <p>Specify locale to get localized commands and arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[AppCommand]</code>         \u2013          <p>A list of AppCommand where guild_id is not specified (global) or guild_id matches the specified guild_id.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>def get_guild_commands(\n    self,\n    guild_id: int,\n    *,\n    include_nsfw: bool = False,\n    permissions: Optional[disnake.Permissions] = None,\n    locale: Optional[disnake.Locale] = None,\n) -&gt; List[AppCommand]:\n\"\"\"Return commands where guild_id is None or guild_id matches specified guild_id.\n\n    !!! Note\n        Including `permissions` will restrict the command list to prevent commands hidden by\n        default_command_permissions from appearing to the command author.\n\n    Parameters\n    ----------\n    guild_id: int\n        ID for the guild for which guild-specific command are registered.\n    include_nsfw: bool\n        Whether or not to include NSFW commands.\n    permissions: Optional[disnake.Permissions]\n        Set the permission limit of the resulting commands.  Any commands that exceed specified\n        permissions will be omitted\n    locale: Optional[disnake.Locale]\n        Specify locale to get localized commands and arguments.\n\n    Returns\n    -------\n    List[AppCommand]\n        A list of AppCommand where guild_id is not specified (global) or guild_id matches\n        the specified guild_id.\n    \"\"\"\n    return self.get_all_commands(\n        guild_id, locale=locale, include_nsfw=include_nsfw, permissions=permissions\n    )\n</code></pre>"},{"location":"reference/helply/helply/#helply.helply.Helply.roles_from_checks","title":"<code>roles_from_checks(checks, guild)</code>  <code>staticmethod</code>","text":"<p>Parse the command's role checks and return a list of <code>disnake.Role</code>.</p> <p>Parameters:</p> <ul> <li> checks             (<code>CommandChecks</code>)         \u2013          <p>A command's checks</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Role]</code>         \u2013          <p><code>Roles</code> that have been successfully converted from name or ID.</p> </li> </ul> Source code in <code>src\\helply\\helply.py</code> <pre><code>@staticmethod\ndef roles_from_checks(checks: CommandChecks, guild: disnake.Guild) -&gt; List[disnake.Role]:\n\"\"\"Parse the command's role checks and return a list of `disnake.Role`.\n\n    Parameters\n    ----------\n    checks : CommandChecks\n        A command's checks\n\n    Returns\n    -------\n    List[disnake.Role]\n        `Roles` that have been successfully converted from name or ID.\n    \"\"\"\n    role_checks = checks.roles\n    roles: List[disnake.Role] = []\n\n    for name_or_id in role_checks:\n        if isinstance(name_or_id, int) or name_or_id.isdigit():\n            role = guild.get_role(int(name_or_id))\n        else:\n            role = disnake.utils.get(guild.roles, name=name_or_id)\n\n        if role:\n            roles.append(role)\n\n    return roles\n</code></pre>"},{"location":"reference/helply/types/argument/","title":"argument","text":"<p>Base classes for the types used within Helply.</p>"},{"location":"reference/helply/types/argument/#helply.types.argument.Argument","title":"<code>Argument</code>  <code>dataclass</code>","text":"<p>Represents a SlashCommand argument.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>Argument's non-localized name</p> </li> <li> description             (<code>str</code>)         \u2013          <p>Argument's non-localized description</p> </li> <li> required             (<code>bool</code>)         \u2013          <p>Whether or not the argument is required.</p> </li> <li> name_localizations             (<code>LocalizationValue</code>)         \u2013          <p>Contains localizations for the argument's name. (New in version 0.3.0)</p> </li> <li> description_localizations             (<code>LocalizationValue</code>)         \u2013          <p>Contains localizations for the argument's description. (New in version 0.3.0)</p> </li> </ul> <p>Methods:</p> <ul> <li> get_localized_name           \u2013            <p>Return localized or non-localized name. (New in version 0.3.0)</p> </li> <li> get_localized_description           \u2013            <p>Return localized or non-localized description. (New in version 0.3.0)</p> </li> <li> localize           \u2013            <p>Return an Argument with localized attributes (New in version 0.3.0)</p> </li> </ul> Source code in <code>src\\helply\\types\\argument.py</code> <pre><code>@dataclass\nclass Argument:\n\"\"\"Represents a SlashCommand argument.\n\n    Attributes\n    ----------\n    name: str\n        Argument's non-localized name\n    description: str\n        Argument's non-localized description\n    required: bool\n        Whether or not the argument is required.\n    name_localizations: disnake.LocalizationValue\n        Contains localizations for the argument's name. (*New in version 0.3.0*)\n    description_localizations: disnake.LocalizationValue\n        Contains localizations for the argument's description. (*New in version 0.3.0*)\n\n    Methods\n    -------\n    get_localized_name(locale: disnake.Locale)\n        Return localized or non-localized name. (*New in version 0.3.0*)\n    get_localized_description(locale: disnake.Locale)\n        Return localized or non-localized description. (*New in version 0.3.0*)\n    localize(locale: disnake.Locale)\n        Return an Argument with localized attributes (*New in version 0.3.0*)\n    \"\"\"\n\n    name: str\n    description: str\n    required: bool\n    name_localizations: LocalizationValue\n    description_localizations: LocalizationValue\n\n    def get_localized_name(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized name. specified by the provided locale.\n\n        If not available, return the non-localized name instead.\n\n        Parameters\n        ----------\n        locale: disnake.Local\n            The interaction locale\n\n        Returns\n        -------\n        str\n            The localized or non-localized name.\n        \"\"\"\n        if not self.name_localizations or not self.name_localizations.data:\n            return self.name\n\n        return self.name_localizations.data.get(str(locale), self.name)\n\n    def get_localized_description(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized description. specified by the provided locale.\n\n        If not available, return the non-localized description instead.\n\n        Parameters\n        ----------\n        locale: disnake.Local\n            The interaction locale\n\n        Returns\n        -------\n        str\n            The localized or non-localized description.\n        \"\"\"\n        if not self.description_localizations or not self.description_localizations.data:\n            return self.name\n\n        return self.description_localizations.data.get(str(locale), self.description)\n\n    def localize(self, locale: Locale) -&gt; Argument:\n\"\"\"Return a Argument instance with localized name and description.\n\n        Parameters\n        ----------\n        locale: disnake.Locale\n            The locale that should be used to localize the argument.\n\n        Returns\n        -------\n        Argument\n            This argument with localized name and description\n        \"\"\"\n        return Argument(\n            name=self.get_localized_name(locale),\n            description=self.get_localized_description(locale),\n            required=self.required,\n            name_localizations=self.name_localizations,\n            description_localizations=self.description_localizations,\n        )\n</code></pre>"},{"location":"reference/helply/types/argument/#helply.types.argument.Argument.get_localized_description","title":"<code>get_localized_description(locale)</code>","text":"<p>Return localized or non-localized description. specified by the provided locale.</p> <p>If not available, return the non-localized description instead.</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The interaction locale</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The localized or non-localized description.</p> </li> </ul> Source code in <code>src\\helply\\types\\argument.py</code> <pre><code>def get_localized_description(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized description. specified by the provided locale.\n\n    If not available, return the non-localized description instead.\n\n    Parameters\n    ----------\n    locale: disnake.Local\n        The interaction locale\n\n    Returns\n    -------\n    str\n        The localized or non-localized description.\n    \"\"\"\n    if not self.description_localizations or not self.description_localizations.data:\n        return self.name\n\n    return self.description_localizations.data.get(str(locale), self.description)\n</code></pre>"},{"location":"reference/helply/types/argument/#helply.types.argument.Argument.get_localized_name","title":"<code>get_localized_name(locale)</code>","text":"<p>Return localized or non-localized name. specified by the provided locale.</p> <p>If not available, return the non-localized name instead.</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The interaction locale</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The localized or non-localized name.</p> </li> </ul> Source code in <code>src\\helply\\types\\argument.py</code> <pre><code>def get_localized_name(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized name. specified by the provided locale.\n\n    If not available, return the non-localized name instead.\n\n    Parameters\n    ----------\n    locale: disnake.Local\n        The interaction locale\n\n    Returns\n    -------\n    str\n        The localized or non-localized name.\n    \"\"\"\n    if not self.name_localizations or not self.name_localizations.data:\n        return self.name\n\n    return self.name_localizations.data.get(str(locale), self.name)\n</code></pre>"},{"location":"reference/helply/types/argument/#helply.types.argument.Argument.localize","title":"<code>localize(locale)</code>","text":"<p>Return a Argument instance with localized name and description.</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The locale that should be used to localize the argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Argument</code>         \u2013          <p>This argument with localized name and description</p> </li> </ul> Source code in <code>src\\helply\\types\\argument.py</code> <pre><code>def localize(self, locale: Locale) -&gt; Argument:\n\"\"\"Return a Argument instance with localized name and description.\n\n    Parameters\n    ----------\n    locale: disnake.Locale\n        The locale that should be used to localize the argument.\n\n    Returns\n    -------\n    Argument\n        This argument with localized name and description\n    \"\"\"\n    return Argument(\n        name=self.get_localized_name(locale),\n        description=self.get_localized_description(locale),\n        required=self.required,\n        name_localizations=self.name_localizations,\n        description_localizations=self.description_localizations,\n    )\n</code></pre>"},{"location":"reference/helply/types/checks/","title":"checks","text":"<p>Checks and Cooldowns used with Helply attributes</p>"},{"location":"reference/helply/types/checks/#helply.types.checks.CommandChecks","title":"<code>CommandChecks</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Wrap the command's permission or role requirements.</p> <p>Attributes:</p> <ul> <li> permissions             (<code>List[str]</code>)         \u2013          <p>A list of permission names required to use this command.</p> </li> <li> roles             (<code>List[Union[str, int]]</code>)         \u2013          <p>A list of role names or role IDs required to use this command.</p> </li> </ul> Source code in <code>src\\helply\\types\\checks.py</code> <pre><code>class CommandChecks(NamedTuple):\n\"\"\"Wrap the command's permission or role requirements.\n\n    Attributes\n    ----------\n    permissions : List[str]\n        A list of permission names required to use this command.\n    roles : List[Union[str, int]]\n        A list of role names or role IDs required to use this command.\n    \"\"\"\n\n    permissions: List[str]\n    roles: List[Union[str, int]]\n</code></pre>"},{"location":"reference/helply/types/checks/#helply.types.checks.Cooldown","title":"<code>Cooldown</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Represents a commands.Cooldown.</p> <p>(New in version: 0.4.0)</p> <p>Attributes:</p> <ul> <li> rate             (<code>int</code>)         \u2013          <p>Number of times the command can be used before triggering a cooldown</p> </li> <li> per             (<code>float</code>)         \u2013          <p>Amount of seconds to wait for a cooldown when it's been triggered</p> </li> <li> type             (<code>str</code>)         \u2013          <p>Type of cooldown</p> </li> </ul> <pre><code>|--------------------------------------------------------------------|\n|   Types    |                   Description                         |\n|------------|-------------------------------------------------------|\n| `default`  | The default bucket operates on a global basis.        |\n| `user`     | The user bucket operates on a per-user basis.         |\n| `guild`    | The guild bucket operates on a per-guild basis.       |\n| `channel`  | The channel bucket operates on a per-channel basis.   |\n| `member`   | The member bucket operates on a per-member basis.     |\n| `category` | The category bucket operates on a per-category basis. |\n| `role`     | The role bucket operates on a per-role basis.         |\n|--------------------------------------------------------------------|\n</code></pre> Source code in <code>src\\helply\\types\\checks.py</code> <pre><code>class Cooldown(NamedTuple):\n\"\"\"Represents a commands.Cooldown.\n\n    (*New in version: 0.4.0*)\n\n    Attributes\n    ----------\n    rate: int\n        Number of times the command can be used before triggering a cooldown\n    per: float\n        Amount of seconds to wait for a cooldown when it's been triggered\n    type: str\n        Type of cooldown\n\n\n\n    ```\n    |--------------------------------------------------------------------|\n    |   Types    |                   Description                         |\n    |------------|-------------------------------------------------------|\n    | `default`  | The default bucket operates on a global basis.        |\n    | `user`     | The user bucket operates on a per-user basis.         |\n    | `guild`    | The guild bucket operates on a per-guild basis.       |\n    | `channel`  | The channel bucket operates on a per-channel basis.   |\n    | `member`   | The member bucket operates on a per-member basis.     |\n    | `category` | The category bucket operates on a per-category basis. |\n    | `role`     | The role bucket operates on a per-role basis.         |\n    |--------------------------------------------------------------------|\n    ```\n    \"\"\"\n\n    rate: int\n    per: float\n    type: str\n</code></pre>"},{"location":"reference/helply/types/commands/","title":"commands","text":"<p>Helply command types</p>"},{"location":"reference/helply/types/commands/#helply.types.commands.AppCommand","title":"<code>AppCommand</code>  <code>dataclass</code>","text":"<p>Base class for all AppCommand types.</p> <p>AppCommands are classes that include various attributes from both <code>.ApplicationCommand</code> and <code>.InvokableApplicationCommand</code></p> <p>Attributes:</p> <ul> <li> id             (<code>int</code>)         \u2013          <p>The command's unique identifier.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>Command's name. (Can be localized)</p> </li> <li> name_             (<code>str</code>)         \u2013          <p>Command's non-localized name. (Needed to maintain static non-localized name for mention)</p> </li> <li> description             (<code>str</code>)         \u2013          <p>Command's description</p> </li> <li> name_localizations             (<code>LocalizationValue</code>)         \u2013          <p>Contains localizations for the command's name. (New in version 0.3.0)</p> </li> <li> checks             (<code>CommandChecks</code>)         \u2013          <p>The command's permission and role requirements.</p> </li> <li> args             (<code>List[Argument]</code>)         \u2013          <p>Contains the command's arguments. (Only applies to SlashCommand)</p> </li> <li> type             (<code>AppCommandType</code>)         \u2013          <p>Type of command</p> </li> <li> category             (<code>str</code>)         \u2013          <p>Name of cog or category the command belongs to</p> </li> <li> dm_permission             (<code>bool</code>)         \u2013          <p>Whether the command is available in DMs or not.</p> </li> <li> nsfw             (<code>bool</code>)         \u2013          <p>Whether the command is NSFW (Not Safe For Work).</p> </li> <li> description_localizations             (<code>Optional[LocalizationValue]</code>)         \u2013          <p>Contains localization information for the command's description. (SlashCommand only) (New in version 0.3.0)</p> </li> <li> cooldown             (<code>Optional[Cooldown]</code>)         \u2013          <p>The configured cooldown, if available. (New in 0.4.0)</p> </li> <li> guild_id             (<code>Optional[int]</code>)         \u2013          <p>The ID of the guild where the command is available.</p> </li> <li> default_member_permissions             (<code>Optional[Permissions]</code>)         \u2013          <p>Default member permissions required to use this command.</p> </li> <li> mention             (<code>str</code>)         \u2013          <p>Get the command as a mentionable if slash command, else return bolded name.</p> </li> </ul> <p>Methods:</p> <ul> <li> get_localized_name           \u2013            <p>Return localized or non-localized name. (New in version 0.3.0)</p> </li> <li> get_localized_description           \u2013            <p>Return localized or non-localized description. (New in version 0.3.0)</p> </li> <li> localize           \u2013            <p>Return an AppCommand with localized attributes. (New in version 0.3.0)</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>@dataclass\nclass AppCommand:\n\"\"\"Base class for all AppCommand types.\n\n    AppCommands are classes that include various attributes from both\n    `.ApplicationCommand` and `.InvokableApplicationCommand`\n\n    Attributes\n    ----------\n    id : int\n        The command's unique identifier.\n    name: str\n        Command's name. (Can be localized)\n    name_: str\n        Command's non-localized name. (*Needed to maintain static non-localized name for mention*)\n    description: str\n        Command's description\n    name_localizations: disnake.LocalizationValue\n        Contains localizations for the command's name. (*New in version 0.3.0*)\n    checks : CommandChecks\n        The command's permission and role requirements.\n    args: List[Argument]\n        Contains the command's arguments. (Only applies to SlashCommand)\n    type: AppCommandType\n        Type of command\n    category: str\n        Name of cog or category the command belongs to\n    dm_permission : bool\n        Whether the command is available in DMs or not.\n    nsfw : bool\n        Whether the command is NSFW (Not Safe For Work).\n    description_localizations: Optional[LocalizationValue]\n        Contains localization information for the command's description. (*SlashCommand only*)\n        (*New in version 0.3.0*)\n    cooldown: Optional[Cooldown]\n        The configured cooldown, if available. (*New in 0.4.0*)\n    guild_id : Optional[int]\n        The ID of the guild where the command is available.\n    default_member_permissions : Optional[Permissions]\n        Default member permissions required to use this command.\n    mention : str\n        Get the command as a mentionable if slash command, else return bolded name.\n\n    Methods\n    -------\n    get_localized_name(locale: Optional[Locale])\n        Return localized or non-localized name. (*New in version 0.3.0*)\n    get_localized_description(locale: disnake.Locale)\n        Return localized or non-localized description. (*New in version 0.3.0*)\n    localize(locale: disnake.Locale)\n        Return an AppCommand with localized attributes. (*New in version 0.3.0*)\n    \"\"\"\n\n    id: int\n    name: str\n    name_: str\n    description: str\n    checks: CommandChecks\n    type: AppCommandType\n    category: str\n    dm_permission: bool\n    nsfw: bool\n    name_localizations: LocalizationValue\n    description_localizations: Optional[LocalizationValue] = None\n    args: List[Argument] = field(default_factory=list)\n    cooldown: Optional[Cooldown] = None\n    guild_id: Optional[int] = None\n    default_member_permissions: Optional[Permissions] = None\n\n    @property\n    def mention(self) -&gt; str:\n\"\"\"Return the clickable tag if SlashCommand, else bolded name.\"\"\"\n        if isinstance(self, SlashCommand):\n            return f\"&lt;/{self.name_}:{self.id}&gt;\"\n        return f\"**{self.name_}**\"\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, AppCommand):\n            return False\n\n        return (\n            self.name == other.name\n            and self.name_ == other.name_\n            and self.type == other.type\n            and self.description == other.description\n            and self.nsfw == other.nsfw\n            and self.category == other.category\n            and self.dm_permission == other.dm_permission\n            and self.dm_permission == other.dm_permission\n            and self.checks == other.checks\n            and self.cooldown == other.cooldown\n        )\n\n    def get_localized_name(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized name. specified by the provided locale.\n\n        If not available return the non-localized name instead.\n\n        Parameters\n        ----------\n        locale: disnake.Locale\n            The interaction locale that will be used to localize attributes.\n\n        Returns\n        -------\n        str\n            The localized or non-localized name.\n        \"\"\"\n        if not self.name_localizations.data:\n            return self.name\n\n        return self.name_localizations.data.get(str(locale), self.name)\n\n    def get_localized_description(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized description. specified by the provided locale.\n\n        If not available, Return the non-localized description instead.\n\n        Parameters\n        ----------\n        locale: disnake.Locale\n            The interaction locale that will be used to localize attributes.\n\n        Returns\n        -------\n        str\n            The localized or non-localized description.\n        \"\"\"\n        if not self.description_localizations or not self.description_localizations.data:\n            return self.description\n\n        return self.description_localizations.data.get(str(locale), self.description)\n\n    def localize(self, locale: Locale) -&gt; AppCommand:\n\"\"\"Return aAppCommand with localized attributes.\n\n        Parameters\n        ----------\n        locale: Locale\n            The interaction locale that will be used to localize attributes.\n\n        Returns\n        -------\n        Appcommand\n            a AppCommand with localized attributes.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.AppCommand.mention","title":"<code>mention: str</code>  <code>property</code>","text":"<p>Return the clickable tag if SlashCommand, else bolded name.</p>"},{"location":"reference/helply/types/commands/#helply.types.commands.AppCommand.get_localized_description","title":"<code>get_localized_description(locale)</code>","text":"<p>Return localized or non-localized description. specified by the provided locale.</p> <p>If not available, Return the non-localized description instead.</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The interaction locale that will be used to localize attributes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The localized or non-localized description.</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>def get_localized_description(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized description. specified by the provided locale.\n\n    If not available, Return the non-localized description instead.\n\n    Parameters\n    ----------\n    locale: disnake.Locale\n        The interaction locale that will be used to localize attributes.\n\n    Returns\n    -------\n    str\n        The localized or non-localized description.\n    \"\"\"\n    if not self.description_localizations or not self.description_localizations.data:\n        return self.description\n\n    return self.description_localizations.data.get(str(locale), self.description)\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.AppCommand.get_localized_name","title":"<code>get_localized_name(locale)</code>","text":"<p>Return localized or non-localized name. specified by the provided locale.</p> <p>If not available return the non-localized name instead.</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The interaction locale that will be used to localize attributes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The localized or non-localized name.</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>def get_localized_name(self, locale: Locale) -&gt; str:\n\"\"\"Return localized or non-localized name. specified by the provided locale.\n\n    If not available return the non-localized name instead.\n\n    Parameters\n    ----------\n    locale: disnake.Locale\n        The interaction locale that will be used to localize attributes.\n\n    Returns\n    -------\n    str\n        The localized or non-localized name.\n    \"\"\"\n    if not self.name_localizations.data:\n        return self.name\n\n    return self.name_localizations.data.get(str(locale), self.name)\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.AppCommand.localize","title":"<code>localize(locale)</code>","text":"<p>Return aAppCommand with localized attributes.</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The interaction locale that will be used to localize attributes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Appcommand</code>         \u2013          <p>a AppCommand with localized attributes.</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>def localize(self, locale: Locale) -&gt; AppCommand:\n\"\"\"Return aAppCommand with localized attributes.\n\n    Parameters\n    ----------\n    locale: Locale\n        The interaction locale that will be used to localize attributes.\n\n    Returns\n    -------\n    Appcommand\n        a AppCommand with localized attributes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.MessageCommand","title":"<code>MessageCommand</code>","text":"<p>             Bases: <code>AppCommand</code></p> <p>Represents a message command type AppCommand.</p> <p>Attributes:</p> <ul> <li> id             (<code>int</code>)         \u2013          <p>The command's unique identifier.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>Command's non-localized name</p> </li> <li> description             (<code>str</code>)         \u2013          <p>Command's non-localized description</p> </li> <li> name_localizations             (<code>LocalizationValue</code>)         \u2013          <p>Contains localizations for the command's name. (New in version 0.3.0)</p> </li> <li> checks             (<code>CommandChecks</code>)         \u2013          <p>The command's permission and role requirements.</p> </li> <li> type             (<code>AppCommandType</code>)         \u2013          <p>Type of command</p> </li> <li> category             (<code>str</code>)         \u2013          <p>Name of cog or category the command belongs to</p> </li> <li> dm_permission             (<code>bool</code>)         \u2013          <p>Whether the command is available in DMs or not.</p> </li> <li> nsfw             (<code>bool</code>)         \u2013          <p>Whether the command is NSFW (Not Safe For Work).</p> </li> <li> cooldown             (<code>Optional[Cooldown]</code>)         \u2013          <p>The configured cooldown, if available. (New in 0.4.0)</p> </li> <li> guild_id             (<code>Optional[int]</code>)         \u2013          <p>The ID of the guild where the command is available.</p> </li> <li> default_member_permissions             (<code>Optional[Permissions]</code>)         \u2013          <p>Default member permissions required to use this command.</p> </li> <li> mention             (<code>str</code>)         \u2013          <p>Get the command as a mentionable if slash command, else return bolded name.</p> </li> </ul> <p>Methods:</p> <ul> <li> get_localized_name           \u2013            <p>Return localized or non-localized name. (New in version 0.3.0)</p> </li> <li> get_localized_description           \u2013            <p>Return localized or non-localized description. (New in version 0.3.0)</p> </li> <li> localize           \u2013            <p>Return a UserCommand with localized attributes. (New in version 0.3.0)</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>class MessageCommand(AppCommand):\n\"\"\"Represents a message command type AppCommand.\n\n    Attributes\n    ----------\n    id : int\n        The command's unique identifier.\n    name: str\n        Command's non-localized name\n    description: str\n        Command's non-localized description\n    name_localizations: disnake.LocalizationValue\n        Contains localizations for the command's name. (*New in version 0.3.0*)\n    checks : CommandChecks\n        The command's permission and role requirements.\n    type: AppCommandType\n        Type of command\n    category: str\n        Name of cog or category the command belongs to\n    dm_permission : bool\n        Whether the command is available in DMs or not.\n    nsfw : bool\n        Whether the command is NSFW (Not Safe For Work).\n    cooldown: Optional[Cooldown]\n        The configured cooldown, if available. (*New in 0.4.0*)\n    guild_id : Optional[int]\n        The ID of the guild where the command is available.\n    default_member_permissions : Optional[Permissions]\n        Default member permissions required to use this command.\n    mention : str\n        Get the command as a mentionable if slash command, else return bolded name.\n\n    Methods\n    -------\n    get_localized_name(locale: Optional[Locale])\n        Return localized or non-localized name. (*New in version 0.3.0*)\n    get_localized_description(locale: disnake.Locale)\n        Return localized or non-localized description. (*New in version 0.3.0*)\n    localize(locale: disnake.Locale)\n        Return a UserCommand with localized attributes. (*New in version 0.3.0*)\n    \"\"\"\n\n    def localize(self, locale: Locale) -&gt; MessageCommand:\n\"\"\"Return a localized instance of MessageCommand\n\n        Parameters\n        ----------\n        locale: Locale\n            The locale to be used for localizing the command.\n\n        Returns\n        -------\n        SlashCommand\n            The localized MessageCommand.\n        \"\"\"\n        name = self.get_localized_name(locale)\n        desc = self.get_localized_description(locale)\n\n        return MessageCommand(\n            id=self.id,\n            name=name,\n            name_=self.name_,\n            description=desc,\n            checks=self.checks,\n            type=self.type,\n            category=self.category,\n            dm_permission=self.dm_permission,\n            nsfw=self.nsfw,\n            name_localizations=self.name_localizations,\n            description_localizations=self.description_localizations,\n            cooldown=self.cooldown,\n            guild_id=self.guild_id,\n            default_member_permissions=self.default_member_permissions,\n        )\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.MessageCommand.localize","title":"<code>localize(locale)</code>","text":"<p>Return a localized instance of MessageCommand</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The locale to be used for localizing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SlashCommand</code>         \u2013          <p>The localized MessageCommand.</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>def localize(self, locale: Locale) -&gt; MessageCommand:\n\"\"\"Return a localized instance of MessageCommand\n\n    Parameters\n    ----------\n    locale: Locale\n        The locale to be used for localizing the command.\n\n    Returns\n    -------\n    SlashCommand\n        The localized MessageCommand.\n    \"\"\"\n    name = self.get_localized_name(locale)\n    desc = self.get_localized_description(locale)\n\n    return MessageCommand(\n        id=self.id,\n        name=name,\n        name_=self.name_,\n        description=desc,\n        checks=self.checks,\n        type=self.type,\n        category=self.category,\n        dm_permission=self.dm_permission,\n        nsfw=self.nsfw,\n        name_localizations=self.name_localizations,\n        description_localizations=self.description_localizations,\n        cooldown=self.cooldown,\n        guild_id=self.guild_id,\n        default_member_permissions=self.default_member_permissions,\n    )\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.SlashCommand","title":"<code>SlashCommand</code>","text":"<p>             Bases: <code>AppCommand</code></p> <p>Represents a slash command type AppCommand.</p> <p>Attributes:</p> <ul> <li> id             (<code>int</code>)         \u2013          <p>The command's unique identifier.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>Command's non-localized name</p> </li> <li> description             (<code>str</code>)         \u2013          <p>Command's non-localized description</p> </li> <li> name_localizations             (<code>LocalizationValue</code>)         \u2013          <p>Contains localizations for the command's name. (New in version 0.3.0)</p> </li> <li> description_localizations             (<code>LocalizationValue</code>)         \u2013          <p>Contains localizations for the command's description. (New in version 0.3.0)</p> </li> <li> args             (<code>List[Argument]</code>)         \u2013          <p>Contains the command's arguments</p> </li> <li> checks             (<code>CommandChecks</code>)         \u2013          <p>The command's permission and role requirements.</p> </li> <li> type             (<code>AppCommandType</code>)         \u2013          <p>Type of command</p> </li> <li> category             (<code>str</code>)         \u2013          <p>Name of cog or category the command belongs to</p> </li> <li> dm_permission             (<code>bool</code>)         \u2013          <p>Whether the command is available in DMs or not.</p> </li> <li> nsfw             (<code>bool</code>)         \u2013          <p>Whether the command is NSFW (Not Safe For Work).</p> </li> <li> cooldown             (<code>Optional[Cooldown]</code>)         \u2013          <p>The configured cooldown, if available. (New in 0.4.0)</p> </li> <li> guild_id             (<code>Optional[int]</code>)         \u2013          <p>The ID of the guild where the command is available.</p> </li> <li> default_member_permissions             (<code>Optional[Permissions]</code>)         \u2013          <p>Default member permissions required to use this command.</p> </li> <li> mention             (<code>str</code>)         \u2013          <p>Get the command as a mentionable if slash command, else return bolded name.</p> </li> </ul> <p>Methods:</p> <ul> <li> get_localized_name           \u2013            <p>Return localized or non-localized name. (New in version 0.3.0)</p> </li> <li> get_localized_description           \u2013            <p>Return localized or non-localized description. (New in version 0.3.0)</p> </li> <li> localize           \u2013            <p>Return a SlashCommand with localized attributes. (New in version 0.3.0)</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>class SlashCommand(AppCommand):\n\"\"\"Represents a slash command type AppCommand.\n\n    Attributes\n    ----------\n    id : int\n        The command's unique identifier.\n    name: str\n        Command's non-localized name\n    description: str\n        Command's non-localized description\n    name_localizations: disnake.LocalizationValue\n        Contains localizations for the command's name. (*New in version 0.3.0*)\n    description_localizations: disnake.LocalizationValue\n        Contains localizations for the command's description. (*New in version 0.3.0*)\n    args: List[Argument]\n        Contains the command's arguments\n    checks : CommandChecks\n        The command's permission and role requirements.\n    type: AppCommandType\n        Type of command\n    category: str\n        Name of cog or category the command belongs to\n    dm_permission : bool\n        Whether the command is available in DMs or not.\n    nsfw : bool\n        Whether the command is NSFW (Not Safe For Work).\n    cooldown: Optional[Cooldown]\n        The configured cooldown, if available. (*New in 0.4.0*)\n    guild_id : Optional[int]\n        The ID of the guild where the command is available.\n    default_member_permissions : Optional[Permissions]\n        Default member permissions required to use this command.\n    mention : str\n        Get the command as a mentionable if slash command, else return bolded name.\n\n    Methods\n    -------\n    get_localized_name(locale: Optional[Locale])\n        Return localized or non-localized name. (*New in version 0.3.0*)\n    get_localized_description(locale: disnake.Locale)\n        Return localized or non-localized description. (*New in version 0.3.0*)\n    localize(locale: disnake.Locale)\n        Return a SlashCommand with localized attributes. (*New in version 0.3.0*)\n    \"\"\"\n\n    def localize(self, locale: Locale) -&gt; SlashCommand:\n\"\"\"Return a localized instance of SlashCommand\n\n        Parameters\n        ----------\n        locale: Locale\n            The locale to be used for localizing the command.\n\n        Returns\n        -------\n        SlashCommand\n            The localized SlashCommand.\n        \"\"\"\n        args = [a.localize(locale) for a in self.args]\n        name = self.get_localized_name(locale)\n        desc = self.get_localized_description(locale)\n\n        return SlashCommand(\n            id=self.id,\n            name=name,\n            name_=self.name_,\n            description=desc,\n            checks=self.checks,\n            type=self.type,\n            category=self.category,\n            dm_permission=self.dm_permission,\n            nsfw=self.nsfw,\n            name_localizations=self.name_localizations,\n            description_localizations=self.description_localizations,\n            cooldown=self.cooldown,\n            guild_id=self.guild_id,\n            default_member_permissions=self.default_member_permissions,\n            args=args,\n        )\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.SlashCommand.localize","title":"<code>localize(locale)</code>","text":"<p>Return a localized instance of SlashCommand</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The locale to be used for localizing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SlashCommand</code>         \u2013          <p>The localized SlashCommand.</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>def localize(self, locale: Locale) -&gt; SlashCommand:\n\"\"\"Return a localized instance of SlashCommand\n\n    Parameters\n    ----------\n    locale: Locale\n        The locale to be used for localizing the command.\n\n    Returns\n    -------\n    SlashCommand\n        The localized SlashCommand.\n    \"\"\"\n    args = [a.localize(locale) for a in self.args]\n    name = self.get_localized_name(locale)\n    desc = self.get_localized_description(locale)\n\n    return SlashCommand(\n        id=self.id,\n        name=name,\n        name_=self.name_,\n        description=desc,\n        checks=self.checks,\n        type=self.type,\n        category=self.category,\n        dm_permission=self.dm_permission,\n        nsfw=self.nsfw,\n        name_localizations=self.name_localizations,\n        description_localizations=self.description_localizations,\n        cooldown=self.cooldown,\n        guild_id=self.guild_id,\n        default_member_permissions=self.default_member_permissions,\n        args=args,\n    )\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.UserCommand","title":"<code>UserCommand</code>","text":"<p>             Bases: <code>AppCommand</code></p> <p>Represents a user command type AppCommand.</p> <p>Attributes:</p> <ul> <li> id             (<code>int</code>)         \u2013          <p>The command's unique identifier.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>Command's non-localized name</p> </li> <li> description             (<code>str</code>)         \u2013          <p>Command's non-localized description</p> </li> <li> name_localizations             (<code>LocalizationValue</code>)         \u2013          <p>Contains localizations for the command's name. (New in version 0.3.0)</p> </li> <li> checks             (<code>CommandChecks</code>)         \u2013          <p>The command's permission and role requirements.</p> </li> <li> type             (<code>AppCommandType</code>)         \u2013          <p>Type of command</p> </li> <li> category             (<code>str</code>)         \u2013          <p>Name of cog or category the command belongs to</p> </li> <li> dm_permission             (<code>bool</code>)         \u2013          <p>Whether the command is available in DMs or not.</p> </li> <li> nsfw             (<code>bool</code>)         \u2013          <p>Whether the command is NSFW (Not Safe For Work).</p> </li> <li> cooldown             (<code>Optional[Cooldown]</code>)         \u2013          <p>The configured cooldown, if available. (New in 0.4.0)</p> </li> <li> guild_id             (<code>Optional[int]</code>)         \u2013          <p>The ID of the guild where the command is available.</p> </li> <li> default_member_permissions             (<code>Optional[Permissions]</code>)         \u2013          <p>Default member permissions required to use this command.</p> </li> <li> mention             (<code>str</code>)         \u2013          <p>Get the command as a mentionable if slash command, else return bolded name.</p> </li> </ul> <p>Methods:</p> <ul> <li> get_localized_name           \u2013            <p>Return localized or non-localized name. (New in version 0.3.0)</p> </li> <li> get_localized_description           \u2013            <p>Return localized or non-localized description. (New in version 0.3.0)</p> </li> <li> localize           \u2013            <p>Return a UserCommand with localized attributes. (New in version 0.3.0)</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>class UserCommand(AppCommand):\n\"\"\"Represents a user command type AppCommand.\n\n\n    Attributes\n    ----------\n    id : int\n        The command's unique identifier.\n    name: str\n        Command's non-localized name\n    description: str\n        Command's non-localized description\n    name_localizations: disnake.LocalizationValue\n        Contains localizations for the command's name. (*New in version 0.3.0*)\n    checks : CommandChecks\n        The command's permission and role requirements.\n    type: AppCommandType\n        Type of command\n    category: str\n        Name of cog or category the command belongs to\n    dm_permission : bool\n        Whether the command is available in DMs or not.\n    nsfw : bool\n        Whether the command is NSFW (Not Safe For Work).\n    cooldown: Optional[Cooldown]\n        The configured cooldown, if available. (*New in 0.4.0*)\n    guild_id : Optional[int]\n        The ID of the guild where the command is available.\n    default_member_permissions : Optional[Permissions]\n        Default member permissions required to use this command.\n    mention : str\n        Get the command as a mentionable if slash command, else return bolded name.\n\n    Methods\n    -------\n    get_localized_name(locale: Optional[Locale])\n        Return localized or non-localized name. (*New in version 0.3.0*)\n    get_localized_description(locale: disnake.Locale)\n        Return localized or non-localized description. (*New in version 0.3.0*)\n    localize(locale: disnake.Locale)\n        Return a UserCommand with localized attributes. (*New in version 0.3.0*)\n    \"\"\"\n\n    def localize(self, locale: Locale) -&gt; UserCommand:\n\"\"\"Return a localized instance of UserCommand\n\n        Parameters\n        ----------\n        locale: Locale\n            The locale to be used for localizing the command.\n\n        Returns\n        -------\n        UserCommand\n            The localized UserCommand.\n        \"\"\"\n        name = self.get_localized_name(locale)\n        desc = self.get_localized_description(locale)\n\n        return UserCommand(\n            id=self.id,\n            name=name,\n            name_=self.name_,\n            description=desc,\n            checks=self.checks,\n            type=self.type,\n            category=self.category,\n            dm_permission=self.dm_permission,\n            nsfw=self.nsfw,\n            name_localizations=self.name_localizations,\n            description_localizations=self.description_localizations,\n            cooldown=self.cooldown,\n            guild_id=self.guild_id,\n            default_member_permissions=self.default_member_permissions,\n        )\n</code></pre>"},{"location":"reference/helply/types/commands/#helply.types.commands.UserCommand.localize","title":"<code>localize(locale)</code>","text":"<p>Return a localized instance of UserCommand</p> <p>Parameters:</p> <ul> <li> locale             (<code>Locale</code>)         \u2013          <p>The locale to be used for localizing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserCommand</code>         \u2013          <p>The localized UserCommand.</p> </li> </ul> Source code in <code>src\\helply\\types\\commands.py</code> <pre><code>def localize(self, locale: Locale) -&gt; UserCommand:\n\"\"\"Return a localized instance of UserCommand\n\n    Parameters\n    ----------\n    locale: Locale\n        The locale to be used for localizing the command.\n\n    Returns\n    -------\n    UserCommand\n        The localized UserCommand.\n    \"\"\"\n    name = self.get_localized_name(locale)\n    desc = self.get_localized_description(locale)\n\n    return UserCommand(\n        id=self.id,\n        name=name,\n        name_=self.name_,\n        description=desc,\n        checks=self.checks,\n        type=self.type,\n        category=self.category,\n        dm_permission=self.dm_permission,\n        nsfw=self.nsfw,\n        name_localizations=self.name_localizations,\n        description_localizations=self.description_localizations,\n        cooldown=self.cooldown,\n        guild_id=self.guild_id,\n        default_member_permissions=self.default_member_permissions,\n    )\n</code></pre>"},{"location":"reference/helply/types/enums/","title":"enums","text":"<p>Helply AppCommand types</p>"},{"location":"reference/helply/types/enums/#helply.types.enums.AppCommandType","title":"<code>AppCommandType</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Represents a command type.</p> <p>Attributes:</p> <ul> <li> SLASH         \u2013          <p>\"slash\"</p> </li> <li> MESSAGE         \u2013          <p>\"message\"</p> </li> <li> USER         \u2013          <p>\"user\"</p> </li> </ul> Source code in <code>src\\helply\\types\\enums.py</code> <pre><code>class AppCommandType(str, enum.Enum):\n\"\"\"Represents a command type.\n\n    Attributes\n    ----------\n    SLASH\n        \"slash\"\n    MESSAGE\n        \"message\"\n    USER\n        \"user\"\n\n    \"\"\"\n\n    SLASH = \"slash\"\n    MESSAGE = \"message\"\n    USER = \"user\"\n</code></pre>"},{"location":"reference/helply/utils/embeds/","title":"embeds","text":"<p>Embeds module adds some pre-configured embeds to streamline the creation of your help command.</p>"},{"location":"reference/helply/utils/embeds/#helply.utils.embeds.MAX_CHARS_PER_FIELD","title":"<code>MAX_CHARS_PER_FIELD = 1024</code>  <code>module-attribute</code>","text":"<p>Set the max and default character limit per embed field.</p> <p>This is a Discord limitation, so we use this for chunking command description lines for the overview embed(s) which allow us to split into multiple fields within a single embed.</p>"},{"location":"reference/helply/utils/embeds/#helply.utils.embeds.MAX_CHARS_PER_FIELD--notes","title":"Notes","text":"<p>I do not recommend exceeding 400 characters as this can create very tall embeds.</p>"},{"location":"reference/helply/utils/embeds/#helply.utils.embeds.MAX_FIELDS_PER_EMBED","title":"<code>MAX_FIELDS_PER_EMBED = 25</code>  <code>module-attribute</code>","text":"<p>Set the max and default field per embed.</p> <p>Discord limits this to 25, so that's what has been set as the max here as well.</p>"},{"location":"reference/helply/utils/embeds/#helply.utils.embeds.command_detail_embed","title":"<code>command_detail_embed(command, *, thumbnail=None, guild=None, color=None)</code>","text":"<p>Create and return an embed showing command details.</p> <p>Parameters:</p> <ul> <li> command             (<code>AppCommand</code>)         \u2013          <p>The <code>AppCommand</code> retrieved from <code>AppCommandHelp.get_command_named</code></p> </li> <li> thumbnail             (<code>Optional[File]</code>, default:                 <code>None</code> )         \u2013          <p>A <code>disnake.File</code> converted image to be set as the embed thumbnail.</p> </li> <li> guild             (<code>Optional[Guild]</code>, default:                 <code>None</code> )         \u2013          <p>Guild where this embed will be displayed. Used to convert any role checks into role objects</p> </li> <li> color             (<code>Optional[Color]</code>, default:                 <code>None</code> )         \u2013          <p>Set the color the embed. Default is None</p> </li> </ul> <p>Examples:</p> <pre><code>from disnake.ext.app_command_help import AppCommandHelp, utils\n\n...\napp_command_help = AppCommandHelp(bot)\n\n...\ncommand = app_command_help.get_command_named(name)\nembed = utils.command_detail_embed(command, guild=inter.guild)\nawait inter.response.send_message(embed=embed)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Embed</code>         \u2013          <p>The created embed containing the command details.</p> </li> </ul> Source code in <code>src\\helply\\utils\\embeds.py</code> <pre><code>def command_detail_embed(\n    command: AppCommand,\n    *,\n    thumbnail: Optional[disnake.File] = None,\n    guild: Optional[disnake.Guild] = None,\n    color: Optional[disnake.Color] = None,\n) -&gt; disnake.Embed:\n\"\"\"Create and return an embed showing command details.\n\n    Parameters\n    ----------\n    command: AppCommand\n        The `AppCommand` retrieved from `AppCommandHelp.get_command_named`\n    thumbnail: Optional[disnake.File]\n        A `disnake.File` converted image to be set as the embed thumbnail.\n    guild: Optional[disnake.Guild]\n        Guild where this embed will be displayed. Used to convert\n        any role checks into role objects\n    color: Optional[disnake.Color]\n        Set the color the embed. Default is None\n\n    Examples\n    --------\n    ```py\n    from disnake.ext.app_command_help import AppCommandHelp, utils\n\n    ...\n    app_command_help = AppCommandHelp(bot)\n\n    ...\n    command = app_command_help.get_command_named(name)\n    embed = utils.command_detail_embed(command, guild=inter.guild)\n    await inter.response.send_message(embed=embed)\n    ```\n\n    Returns\n    -------\n    disnake.Embed\n        The created embed containing the command details.\n    \"\"\"\n    type_ = (\n        \"Slash Command Details\"\n        if command.type is AppCommandType.SLASH\n        else \"User Command Details\"\n        if command.type is AppCommandType.USER\n        else \"Message Command Details\"\n    )\n\n    embed = disnake.Embed(description=f\"{command.mention}\\n{command.description}\", color=color)\n    embed.set_author(name=f'{type_} {\"(NSFW)\" if command.nsfw else \"\"}')\n    if thumbnail:\n        embed.set_thumbnail(file=thumbnail)\n\n    if command.cooldown:\n        cooldown = command.cooldown\n        text = f\"{cooldown.rate} / {cooldown.per}s / {cooldown.type}\"\n        embed.add_field(name=\"Cooldown\", value=text, inline=False)\n\n    if command.checks.permissions:\n        permissions = \", \".join(command.checks.permissions)\n        embed.add_field(name=\"Required Permissions\", value=permissions, inline=True)\n\n    if command.checks.roles:\n        if guild:\n            roles = Helply.roles_from_checks(command.checks, guild)\n            role_checks = \", \".join(r.mention for r in roles)\n        else:\n            role_checks = \", \".join(str(check) for check in command.checks.roles)\n\n        roles_as_string = f\"**Required Roles**:\\n{role_checks}\"\n        embed.add_field(name=\"Required Role(s)\", value=roles_as_string, inline=True)\n\n    if command.type is AppCommandType.SLASH:\n        embed.set_footer(text=\"[ required ] | ( optional )\")\n        if command.args:\n            args: str = \"\"\n\n            for arg in command.args:\n                name = f\"**[{arg.name}]**\" if arg.required else f\"**({arg.name})**\"\n                args += f\"{name}: *{arg.description}*\\n\"\n\n            embed.add_field(name=\"Parameters\", value=args, inline=False)\n        else:\n            embed.add_field(name=\"Parameters\", value=\"None\", inline=True)\n\n    return embed\n</code></pre>"},{"location":"reference/helply/utils/embeds/#helply.utils.embeds.commands_overview_embeds","title":"<code>commands_overview_embeds(commands, *, thumbnail=None, max_field_chars=MAX_CHARS_PER_FIELD, max_fields=MAX_FIELDS_PER_EMBED, color=None, category='')</code>","text":"<p>Create and return one or more embeds containing all commands and descriptions.</p> <p>Parameters:</p> <ul> <li> commands             (<code>List[AppCommand]</code>)         \u2013          <p>List of <code>AppCommand</code> received from <code>AppCommandHelp.get_all_commands</code></p> </li> <li> thumbnail             (<code>Optional[File]</code>, default:                 <code>None</code> )         \u2013          <p>A <code>disnake.File</code> converted image to be set as the embed thumbnail.</p> </li> <li> max_field_chars             (<code>int</code>, default:                 <code>MAX_CHARS_PER_FIELD</code> )         \u2013          <p>Max number of characters per embed field description, default is MAX_CHARS_PER_FIELD (1024)</p> </li> <li> max_fields             (<code>int</code>, default:                 <code>MAX_FIELDS_PER_EMBED</code> )         \u2013          <p>Max number of fields per embed. default is MAX_FIELDS_PER_EMBED (10)</p> </li> <li> color             (<code>Optional[Color]</code>, default:                 <code>None</code> )         \u2013          <p>Set the color the embed(s). Default is None</p> </li> </ul> <p>Examples:</p> <pre><code>from disnake.ext.app_command_help import AppCommandHelp, utils\n\n...\napp_command_help = AppCommandHelp(bot)\n\n...\ncommands = app_command_help.get_all_commands(inter.guild)\nembeds = utils.commands_overview_embeds(commands)\nawait inter.response.send_message(embeds=embeds)\n</code></pre> <p>Returns:</p> <ul> <li> <code>List[Embed]</code>         \u2013          <p>A list of disnake.Embed containing an overview of the commands.</p> </li> </ul> Source code in <code>src\\helply\\utils\\embeds.py</code> <pre><code>def commands_overview_embeds(\n    commands: List[AppCommand],\n    *,\n    thumbnail: Optional[disnake.File] = None,\n    max_field_chars: int = MAX_CHARS_PER_FIELD,\n    max_fields: int = MAX_FIELDS_PER_EMBED,\n    color: Optional[disnake.Color] = None,\n    category: str = \"\",\n) -&gt; List[disnake.Embed]:\n\"\"\"Create and return one or more embeds containing all commands and descriptions.\n\n    Parameters\n    ----------\n    commands: List[AppCommand]\n        List of `AppCommand` received from `AppCommandHelp.get_all_commands`\n    thumbnail: Optional[disnake.File]\n        A `disnake.File` converted image to be set as the embed thumbnail.\n    max_field_chars: int\n        Max number of characters per embed field description, default is MAX_CHARS_PER_FIELD (1024)\n    max_fields: int\n        Max number of fields per embed. default is MAX_FIELDS_PER_EMBED (10)\n    color: Optional[disnake.Color]\n        Set the color the embed(s). Default is None\n\n\n    Examples\n    --------\n    ```py\n    from disnake.ext.app_command_help import AppCommandHelp, utils\n\n    ...\n    app_command_help = AppCommandHelp(bot)\n\n    ...\n    commands = app_command_help.get_all_commands(inter.guild)\n    embeds = utils.commands_overview_embeds(commands)\n    await inter.response.send_message(embeds=embeds)\n    ```\n\n    Returns\n    -------\n    List[disnake.Embed]\n        A list of disnake.Embed containing an overview of the commands.\n    \"\"\"\n    if max_field_chars &gt; MAX_CHARS_PER_FIELD:\n        max_field_chars = MAX_CHARS_PER_FIELD\n\n    if max_fields &gt; MAX_FIELDS_PER_EMBED:\n        max_fields = MAX_FIELDS_PER_EMBED\n\n    embeds: list[disnake.Embed] = []\n    current_embed: Optional[disnake.Embed] = None\n    current_field: str = \"\"\n    current_field_chars: int = 0\n\n    for command in commands:\n        type_ = (\n            \"Slash Command\"\n            if command.type is AppCommandType.SLASH\n            else \"User Command\"\n            if command.type is AppCommandType.USER\n            else \"Message Command\"\n        )\n\n        nsfw = \"*(NSFW)*\" if command.nsfw else \"\"\n\n        command_lines = f\"{command.mention} *({type_})* {nsfw}\\n{command.description}\\n\\n\"\n\n        if current_embed is None:\n            title = (\n                f\"{category} Commands Overview\"\n                if not embeds\n                else f\"{category} Commands Overview (continued)\"\n            )\n            current_embed = _create_base_embed(title, color, thumbnail)\n            current_field_chars = 0\n\n        if current_field_chars + len(command_lines) &lt;= max_field_chars:\n            current_field += command_lines\n            current_field_chars += len(command_lines)\n        else:\n            current_embed.add_field(name=\"\\u200b\", value=current_field, inline=False)\n            current_field = command_lines\n            current_field_chars = len(command_lines)\n\n        if len(current_embed.fields) &gt;= max_fields:\n            embeds.append(current_embed)\n            current_embed = None\n\n    if current_embed is not None:\n        current_embed.add_field(name=\"\\u200b\", value=current_field, inline=False)\n        embeds.append(current_embed)\n\n    return embeds\n</code></pre>"},{"location":"reference/helply/utils/paginator/","title":"paginator","text":"<p>Provides a basic Paginator to provide a clean interface for users to navigator your multiple embeds.</p> <p>Note</p> <p>This can be used for pretty much any list of disnake.Embed</p>"},{"location":"reference/helply/utils/paginator/#helply.utils.paginator.Paginator","title":"<code>Paginator</code>","text":"<p>             Bases: <code>View</code></p> <p>Provides a basic paginator View that allows users to navigate over multiple embeds.</p> <p>Inspired by the paginator.py example provided by disnake</p> <p>Attributes:</p> <ul> <li> message             (<code>InteractionMessage</code>)         \u2013          <p>The interaction message associated with this Paginator. Only useful if a timeout has been provided and the original response will need to be edited.</p> </li> </ul> <p>Parameters:</p> <ul> <li> embeds             (<code>List[Embed]</code>)         \u2013          <p>List of embeds that will be cycled through</p> </li> <li> user             (<code>Optional[Member]</code>, default:                 <code>None</code> )         \u2013          <p>Include a user to prevent others from using buttons.</p> </li> <li> timeout             (<code>float</code>, default:                 <code>180.0</code> )         \u2013          <p>Set the timeout in seconds.</p> </li> </ul> Source code in <code>src\\helply\\utils\\paginator.py</code> <pre><code>class Paginator(disnake.ui.View):\n\"\"\"Provides a basic paginator View that allows users to navigate over multiple embeds.\n\n    Inspired by the paginator.py example provided by\n    [disnake](https://github.com/DisnakeDev/disnake/blob/stable/examples/views/button/paginator.py)\n\n    Attributes\n    ----------\n    message: disnake.InteractionMessage\n        The interaction message associated with this Paginator.\n        Only useful if a timeout has been provided and the original response will need to be\n        edited.\n\n    Parameters\n    ----------\n    embeds: List[disnake.Embed]\n        List of embeds that will be cycled through\n    user: disnake.User, optional\n        Include a user to prevent others from using buttons.\n    timeout: float\n        Set the timeout in seconds.\n    \"\"\"\n\n    message: disnake.InteractionMessage\n\n    def __init__(\n        self,\n        *,\n        embeds: List[disnake.Embed],\n        user: Optional[disnake.Member] = None,\n        timeout: float = 180.0,\n    ) -&gt; None:\n        super().__init__(timeout=timeout)\n        self.user: Optional[disnake.Member] = user\n        self.embeds: List[disnake.Embed] = embeds\n        self.index: int = 0\n\n        self._update_state()\n\n    async def on_timeout(self) -&gt; None:\n\"\"\"Call when Paginator has timed out.\n\n        Requires a Paginator.message to be set and timeout to not be `None`\n\n        Example\n        --------\n        ```py\n        view = utils.Paginator(embeds=embeds, timeout=300)\n        await inter.response.send_message(view=view)\n        view.message = await inter.original_response()\n        ```\n        \"\"\"\n        if message := getattr(self, \"message\", None):\n            try:\n                await message.edit(view=None)\n            except disnake.NotFound:\n                # message may have already been deleted\n                pass\n\n    async def interaction_check(self, interaction: disnake.MessageInteraction) -&gt; bool:\n\"\"\"Check if interaction.author is allowed to interact.\n\n        If no member is provided to Paginator, this check always returns True\n\n        Parameters\n        ----------\n        interaction: disnake.MessageInteraction\n            The interaction invoked by a button\n\n        Returns\n        -------\n        bool\n            True if the interaction check passes and the button callback should be invoked,\n            else False and the callback will not be invoked.\n        \"\"\"\n        if self.user and self.user.id != interaction.author.id:\n            await interaction.response.send_message(\n                \"You do not have permission to interact with this button.\", ephemeral=True\n            )\n            return False\n\n        return True\n\n    def _update_state(self) -&gt; None:\n\"\"\"\n        Update the \"state\" of the view.\n\n        Enable/disable navigation buttons and update the disable counter component\n        \"\"\"\n        self._page_counter.label = f\"{self.index + 1} / {len(self.embeds)}\"\n        self._first_page.disabled = self._prev_page.disabled = self.index == 0\n        self._last_page.disabled = self._next_page.disabled = self.index == len(self.embeds) - 1\n\n    @disnake.ui.button(label=\"First Page\", style=disnake.ButtonStyle.primary)\n    async def _first_page(\n        self, _: disnake.ui.Button[Paginator], inter: disnake.MessageInteraction\n    ) -&gt; None:\n\"\"\"Jump to the first embed.\"\"\"\n        self.index = 0\n        self._update_state()\n\n        await inter.response.edit_message(embed=self.embeds[self.index], view=self)\n\n    @disnake.ui.button(label=\"Prev Page\", style=disnake.ButtonStyle.primary)\n    async def _prev_page(\n        self, _: disnake.ui.Button[Paginator], inter: disnake.MessageInteraction\n    ) -&gt; None:\n\"\"\"Go back one page.\"\"\"\n        self.index -= 1\n        self._update_state()\n\n        await inter.response.edit_message(embed=self.embeds[self.index], view=self)\n\n    @disnake.ui.button(label=\"\", style=disnake.ButtonStyle.primary, disabled=True)\n    async def _page_counter(\n        self, _: disnake.ui.Button[Paginator], inter: disnake.MessageInteraction\n    ) -&gt; None:\n\"\"\"Just a page counter and cannot be interacted with.\"\"\"\n\n    @disnake.ui.button(label=\"Next Page\", style=disnake.ButtonStyle.primary)\n    async def _next_page(\n        self, _: disnake.ui.Button[Paginator], inter: disnake.MessageInteraction\n    ) -&gt; None:\n\"\"\"Go to next page.\"\"\"\n        self.index += 1\n        self._update_state()\n\n        await inter.response.edit_message(embed=self.embeds[self.index], view=self)\n\n    @disnake.ui.button(label=\"Last Page\", style=disnake.ButtonStyle.primary)\n    async def _last_page(\n        self, _: disnake.ui.Button[Paginator], inter: disnake.MessageInteraction\n    ) -&gt; None:\n\"\"\"Go to last page.\"\"\"\n        self.index = len(self.embeds) - 1\n        self._update_state()\n\n        await inter.response.edit_message(embed=self.embeds[self.index], view=self)\n</code></pre>"},{"location":"reference/helply/utils/paginator/#helply.utils.paginator.Paginator.interaction_check","title":"<code>interaction_check(interaction)</code>  <code>async</code>","text":"<p>Check if interaction.author is allowed to interact.</p> <p>If no member is provided to Paginator, this check always returns True</p> <p>Parameters:</p> <ul> <li> interaction             (<code>MessageInteraction</code>)         \u2013          <p>The interaction invoked by a button</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the interaction check passes and the button callback should be invoked, else False and the callback will not be invoked.</p> </li> </ul> Source code in <code>src\\helply\\utils\\paginator.py</code> <pre><code>async def interaction_check(self, interaction: disnake.MessageInteraction) -&gt; bool:\n\"\"\"Check if interaction.author is allowed to interact.\n\n    If no member is provided to Paginator, this check always returns True\n\n    Parameters\n    ----------\n    interaction: disnake.MessageInteraction\n        The interaction invoked by a button\n\n    Returns\n    -------\n    bool\n        True if the interaction check passes and the button callback should be invoked,\n        else False and the callback will not be invoked.\n    \"\"\"\n    if self.user and self.user.id != interaction.author.id:\n        await interaction.response.send_message(\n            \"You do not have permission to interact with this button.\", ephemeral=True\n        )\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/helply/utils/paginator/#helply.utils.paginator.Paginator.on_timeout","title":"<code>on_timeout()</code>  <code>async</code>","text":"<p>Call when Paginator has timed out.</p> <p>Requires a Paginator.message to be set and timeout to not be <code>None</code></p>"},{"location":"reference/helply/utils/paginator/#helply.utils.paginator.Paginator.on_timeout--example","title":"Example","text":"<pre><code>view = utils.Paginator(embeds=embeds, timeout=300)\nawait inter.response.send_message(view=view)\nview.message = await inter.original_response()\n</code></pre> Source code in <code>src\\helply\\utils\\paginator.py</code> <pre><code>async def on_timeout(self) -&gt; None:\n\"\"\"Call when Paginator has timed out.\n\n    Requires a Paginator.message to be set and timeout to not be `None`\n\n    Example\n    --------\n    ```py\n    view = utils.Paginator(embeds=embeds, timeout=300)\n    await inter.response.send_message(view=view)\n    view.message = await inter.original_response()\n    ```\n    \"\"\"\n    if message := getattr(self, \"message\", None):\n        try:\n            await message.edit(view=None)\n        except disnake.NotFound:\n            # message may have already been deleted\n            pass\n</code></pre>"}]}